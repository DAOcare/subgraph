type Project @entity {
  id: ID! #<projectId>
  benefactor: User!
  projectDataIdentifier: String!
  projectState: String!
  projectVoteResults: [VoteStatus!]
  iterationsWon: [Iteration!]
}

type User @entity {
  id: ID! #<usersAddress>
  amount: BigInt!
  timeJoinedLeft: [BigInt!]! # so we can see a history of when they joined and left and if they joined again
  iterationJoinedLeft: [Iteration!]! # if user joins and leaves in the same iteration, won't be appended again it seems
  votes: [Vote!]
  projects: [Project!] # If empty this user has no project. They can have multiple projects, but only one active.
}

type VoteStatus @entity {
  id: ID! # <iteration>-<projectId>
  projectVote: BigInt!
}

type Vote @entity {
  id: ID! # <iteration>-<projectId>-<address>
  voteAmount: BigInt!
  voter: User!
  proxyVoteAddress: Bytes
}

type Iteration @entity {
  id: ID! # <iteration>
  projectVoteTallies: [VoteStatus!]
  individualVotes: [Vote!]
  totalVotes: BigInt!
  winningProposal: Project # there might not be a winning proposal (iteration 0)
  fundsDistributed: BigInt!
  winningVotes: BigInt!
  interestDistribution: [BigInt!]
  iterationStartTimestamp: BigInt!
  iterationEndTimestamp: BigInt
  minerAddress: Bytes
}

# add total deposited and other stats
# add total number of users etc...
type VoteManager @entity {
  id: ID! # this should be a singleton. Give it a constant id of "VOTE_MANAGER"
  currentIteration: Iteration!
  latestCompleteIteration: Iteration
  totalDeposited: BigInt!
  totalDepositedUsers: BigInt!
  totalDepositedProjects: BigInt!
  numberOfUsers: BigInt!
  numberOfProjects: BigInt!
}
